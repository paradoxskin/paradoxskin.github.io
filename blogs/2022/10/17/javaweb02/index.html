<!DOCTYPE html>
<html id="all">

<head>
	<meta charset="utf-8">

















<link rel="shortcut icon" href="/pic/favicon.ico">
	<title>Paradoxless | Blogs</title>
	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="/css/font.css">

	
<link rel="stylesheet" href="/lib/highlight/rainbow.min.css">

<meta name="generator" content="Hexo 5.4.2"></head>
	
<script src="/lib/highlight/highlight.min.js"></script>

	
<script src="/lib/highlight/highlightjs-line-numbers.js"></script>

	
<script src="/lib/jquery.js"></script>

	
<script src="/lib/jquery.pjax.js"></script>

	
<script src="/js/main.js"></script>

<body id="lybody">
	<div id="head">
	<a id="pLogo" href="/"><img alt="P" src="/pic/logo.svg"></a>
	<div id="urlText">aradoxskin.</div>
	<a id="githubLogo" href="https://github.com/paradoxskin" target="_blank"><img alt="github" src="/pic/github.svg"></a>
	<div id="urlText">.io</div>
	<div id="sucklessText">- simple is best</div>
	<div id="clear"></div>
</div>

	<hr id="hidden">
	<script>
	if(localStorage.getItem('bgs')==null){
		localStorage['bgs']='comp'

			localStorage.setItem('bgs[num]','21');

			localStorage.setItem('bgs[pic1]','/pic/wp/01.jpg');

			localStorage.setItem('bgs[pic2]','/pic/wp/02.jpg');

			localStorage.setItem('bgs[pic3]','/pic/wp/03.jpg');

			localStorage.setItem('bgs[pic4]','/pic/wp/04.jpg');

			localStorage.setItem('bgs[pic5]','/pic/wp/05.jpg');

			localStorage.setItem('bgs[pic6]','/pic/wp/06.jpg');

			localStorage.setItem('bgs[pic7]','/pic/wp/07.jpg');

			localStorage.setItem('bgs[pic8]','/pic/wp/08.jpg');

			localStorage.setItem('bgs[pic9]','/pic/wp/09.jpg');

			localStorage.setItem('bgs[pic10]','/pic/wp/10.jpg');

			localStorage.setItem('bgs[pic11]','/pic/wp/11.jpg');

			localStorage.setItem('bgs[pic12]','/pic/wp/12.jpg');

			localStorage.setItem('bgs[pic13]','/pic/wp/13.png');

			localStorage.setItem('bgs[pic14]','/pic/wp/14.png');

			localStorage.setItem('bgs[pic15]','/pic/wp/15.png');

			localStorage.setItem('bgs[pic16]','/pic/wp/16.jpg');

			localStorage.setItem('bgs[pic17]','/pic/wp/17.jpg');

			localStorage.setItem('bgs[pic18]','/pic/wp/18.jpg');

			localStorage.setItem('bgs[pic19]','/pic/wp/19.jpg');

			localStorage.setItem('bgs[pic20]','/pic/wp/20.jpg');

			localStorage.setItem('bgs[pic21]','/pic/wp/21.jpg');

		localStorage.setItem('now','#')
	}
</script>

<div id="nav">
	<ul>
		<li><button id="cgBg" onclick="randomSwitch()">O</button><button id="clBg" onclick="noBg()">_</button></li>

		<iframe id="music-player" frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&id=7669623816&auto=0&height=90"></iframe>

		<button id="nav-hide" onclick="hideMenu()">◤</button>

		<span id="clear"></span>
	</ul>
</div>
<button id="nav-show" onclick="showMenu()">◢</button>

<span id="pup">
	<div id="menu">
	
	
		
			<b><a href="/" class="menu-item-link" id="in">Home</a></b>
		
	
		
			<b><a data-pjax="#main" href="/blogs" class="menu-item-link-selected" id="in">Blogs</a></b>
		
	
		
			<b><a href="/archives" class="menu-item-link" id="in">Archives</a></b>
		
	
		
			<b><a href="/about" class="menu-item-link" id="in">who@mi</a></b>
		
	
		
			<b><a href="/links" class="menu-item-link" id="in">Links</a></b>
		
	
	<div id="outlink">
	
		<a href="https://www.lexaloffle.com/pico-8.php" class="menu-item-link" id="out" target="_blank">pico-8</a>
	
		<a href="https://suckless.org/" class="menu-item-link" id="out" target="_blank">suckless</a>
	
	</div>
</div>

	<div id="main">
		<div id="post">

    <h1 id="第二章-Get"><a href="#第二章-Get" class="headerlink" title="第二章 Get"></a>第二章 Get</h1><p>开发使用eclipse，可能会有一些配置问题需要解决</p>
<h2 id="创建动态web项目"><a href="#创建动态web项目" class="headerlink" title="创建动态web项目"></a>创建动态web项目</h2><p>新建一个<strong>dynamic web project</strong></p>
<p>展开新建的web项目-&gt;展开java resources-&gt;右键src-&gt;创建Servlet窗口-&gt;java package输出controller，class name随意，父类为HTTPServlet</p>
<ul>
<li>  Servlet程序负责扮演控制器的角色，弗雷HTTPServlet专门用于处理HTTP请求，所有的Servlet程序一般都需要继承HTTPServlet</li>
</ul>
<p>打开新建的文件，发现一堆函数被标红了，这是因为HTTPServlet类定义在第三方库servlet-api.jar中，所以我们需要先导入这个库</p>
<p>在tomcat的lib文件夹里找到这个文件，然后对着eclipse里的项目右键，选择属性，找到java构建路径，点击添加外部jar，然后找到之前lib的那个文件，点确定就可以了</p>
<pre><code class="java">package controller;

import java.io.IOException;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(&quot;/ABCServlet&quot;)
public class ABCServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;

    public ABCServlet() &#123;
        System.out.println(&quot;执行ABCServlet的构造方法&quot;);
    &#125;

    public void init(ServletConfig config) throws ServletException &#123;
        System.out.println(&quot;执行ABCServlet的init方法&quot;);
    &#125;

    public void destroy() &#123;
        System.out.println(&quot;执行ABCServlet的destroy方法&quot;);
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        System.out.println(&quot;执行ABCServlet的doGet方法&quot;);
        System.out.println(&quot;根目录的绝对物理路径是&quot;+request.getServletContext().getRealPath(&quot;&quot;));
        System.out.println(&quot;执行完毕&quot;);
    &#125;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        System.out.println(&quot;执行ABCServlet的doPost方法&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="把tomcat集成到eclipse"><a href="#把tomcat集成到eclipse" class="headerlink" title="把tomcat集成到eclipse"></a>把tomcat集成到eclipse</h2><p>servlet需要servler容器才能运行，tomcat提供容器，eclipse只是一个开发环境，没有提供tomcat，所以需要把第1章的tomcat集成到eclipse里</p>
<p>进入servers视图，单击click this link to create a new server，在新建页面里找到apache文件夹，选择tomcat v9.0，之后输入本地tomcat的文件夹路径，下一步到部署项目那里，把之前新建的项目add到configured里就可以finish了</p>
<h2 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h2><p>右键新建的服务器，点击start，服务器就可以部署到本地了</p>
<h2 id="运行第一个servlet程序"><a href="#运行第一个servlet程序" class="headerlink" title="运行第一个servlet程序"></a>运行第一个servlet程序</h2><p>servlet程序不会自动运行，在浏览器输入servlet程序的url才会被执行，打开浏览器，访问<code>http://localhost:8080/get/文件名前缀</code>，然后再控制台就能看到程序的输出了</p>
<h2 id="url-mappings和urlPatterns"><a href="#url-mappings和urlPatterns" class="headerlink" title="url mappings和urlPatterns"></a>url mappings和urlPatterns</h2><p>url mappings描述了服务器位置和本地文件位置的关系，上面代码中的<code>@WebServlet(&quot;/ABCServlet&quot;)</code>就是将浏览器地址栏url中的ABCServlet映射成ABCServlet.java的物理文件，而urlPatterns是指url mappings可以映射到多个：<code>@WebServlet(urlPatterns=&#123;&quot;/ABCServlet&quot;,&quot;/helloServlet&quot;&#125;)</code>，那么你访问这两个地址都会指向同一个程序，甚至还支持<code>/*</code></p>
<h2 id="servlet程序的生命周期"><a href="#servlet程序的生命周期" class="headerlink" title="servlet程序的生命周期"></a>servlet程序的生命周期</h2><p>servlet的生命周期不同于普通的java程序，不会在运行完之后立即退出，而是一直等待，所以构建函数也只会执行一次</p>
<p>普通的java程序生命周期如下图</p>
<p><img src="http://parad0xpic.oss-cn-hangzhou.aliyuncs.com/image-for-pyup/normal.png" alt="normal"></p>
<p>而servlet程序的生命周期如下图</p>
<p><img src="http://parad0xpic.oss-cn-hangzhou.aliyuncs.com/image-for-pyup/servlet.png" alt="servlet"></p>
<p>只有在停止服务器的时候，才会终止程序</p>
<p>为了提高开发效率，eclipse还提供了一种机制，eclipse能自动判断servlet源码是否被更改，如果被更改，就会重新编译并重启tomcat</p>
<h2 id="创建JSP程序"><a href="#创建JSP程序" class="headerlink" title="创建JSP程序"></a>创建JSP程序</h2><p>在webContent目录下创建abc.jsp文件，</p>
<p>在该文件的&lt;body&gt;和&lt;/body&gt;中间输入以下代码</p>
<pre><code class="jsp">&lt;%
    System.out.println(&quot;你好，Tomcat控制台&quot;);
    String realPath = request.getServletContext().getRealPath(&quot;&quot;);
    response.getWriter().print(&quot;你好，项目部署后的绝对路径为&quot; + realPath);
%&gt;
</code></pre>
<p>如果出现乱码问题，就把文件里的<code>ISO-8859-1</code>编码改成<code>UTF-8</code>就行了</p>
<h2 id="JSP和Servlet之间的关系"><a href="#JSP和Servlet之间的关系" class="headerlink" title="JSP和Servlet之间的关系"></a>JSP和Servlet之间的关系</h2><p>java web开发的核心就是Servlet程序的开发，JSP程序本质上是一个Servlet程序，当浏览器用户第一次访问JSP程序时，Tomcat服务的JSP引擎先将JSP程序翻译成Servlet源代码文件，之后就像上面Servlet程序的逻辑一样</p>
<p>JSP也可以视作是一个包含java的html页面，JSP更侧重与前端方面，Servlet可以视作包含html的java文件，更侧重与控制，逻辑</p>
<p>JSP更像是页面模板，之前用过ejs，有点类似</p>
<h2 id="有关JSP的字符编码"><a href="#有关JSP的字符编码" class="headerlink" title="有关JSP的字符编码"></a>有关JSP的字符编码</h2><p>关于JSP的编码有三个细节，第一个是JSP文件的编码形式，第二个是写在开头的pageEncoding，第三个是charset，处理这三个编码的具体逻辑是</p>
<ul>
<li>  按文件编码打开JSP文件</li>
<li>  JSP引擎根据pageEncoding按照指定的字符集读取JSP文件</li>
<li>  charset告诉浏览器应该用什么样的编码来解析HTTP响应</li>
</ul>
<p>当没有指定本地文件用什么样的编码储存时，eclipse会默认采用pageEncoding的编码存储，当文件中出现编码没有的字符时，eclipse就无法保存</p>
<h2 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h2><p>全称Multipurpose Internet Mail Extensions，描述消息内容类型的互联网标准，语法格式为<code>type/subtype</code>type大致有三类<code>text/*</code>,<code>image/*</code>,<code>appliction/*</code></p>
<h2 id="GET请求数据的构成"><a href="#GET请求数据的构成" class="headerlink" title="GET请求数据的构成"></a>GET请求数据的构成</h2><ol>
<li> GET请求行，由3部分组成，中间用空格分隔<code>GET 请求路径?请求查询字符串 请求协议/协议版本</code></li>
<li>GET请求头列表<ul>
<li>  Host：<code>服务器的主机域名或IP:端口号</code></li>
<li>  Connection：连接状态，keep-alive表示与服务器建立长久连接</li>
<li>  User-Agent：发出请求浏览器的类型、版本、操作系统信息等</li>
<li>  Accept：浏览器支持的MIME</li>
<li>  Accept-Encoding：支持的数据压缩方式</li>
<li>  Accept-Language：支持的语言种类</li>
<li>  Upgrade-Insecure-Requests：浏览器是否支持自动升级请求功能</li>
</ul>
</li>
<li> 空行，一般为回车符+换行符，目的是告诉服务器请求头列表到此结束</li>
</ol>
<h2 id="GET全过程"><a href="#GET全过程" class="headerlink" title="GET全过程"></a>GET全过程</h2><ol>
<li><p> 在浏览器上输入URL</p>
</li>
<li><p> 按下Enter键，浏览器自动将URL封装成GET请求</p>
</li>
<li><p> 主机和WEB服务器建立连接，一般为TCP/IP</p>
</li>
<li><p> 浏览器将封装好的GET请求发送给服务器，等待服务器响应</p>
</li>
</ol>
<hr>
<ol start="5">
<li> 服务器接收到GET请求数据，将各种信息封装到HttpServletRequest请求对象中</li>
<li> 根据GET请求行中的请求路径，Tomcat调用构造方法，创建出实例对象，调用init方法初始化实例对象</li>
<li> 将5中封装好的请求对象传入Servlet实例对象的doGet或者doPost方法</li>
<li> 执行方法</li>
<li> doGet依次完成以下操作：获取HTTP请求数据；调用业务逻辑代码，处理HTTP请求数据了；将处理结果封装成HTTP响应数据</li>
<li> 浏览器接收HTTP响应数据，显示结果，等待发起新的HTTP请求</li>
<li> 如果一段时间内服务器和浏览器没有发生数据传输，他们之间的网络连接将会断开</li>
<li> 服务器停止服务，调用destroy销毁</li>
</ol>
<h2 id="request请求对象获取GET请求数据"><a href="#request请求对象获取GET请求数据" class="headerlink" title="request请求对象获取GET请求数据"></a>request请求对象获取GET请求数据</h2><p>方法很多，主要分为六类</p>
<ol>
<li> 获取路径信息</li>
<li> 获取GET请求参数信息</li>
<li> 获取GET请求行信息</li>
<li> 获取GET请求头信息</li>
<li> 获取Web服务器主机和浏览器主机信息</li>
<li> 获取URL Mappings</li>
</ol>
<pre><code class="java">//路径信息
System.out.println(request.getContextPath());
System.out.println(request.getServletContext().getRealPath(&quot;&quot;));
System.out.println(request.getServletContext().getRealPath(&quot;/b/c&quot;));
System.out.println(request.getServletContext().getRealPath(&quot;/b/c/&quot;));
System.out.println(request.getServletContext().getRealPath(&quot;b/c&quot;));
System.out.println(request.getServletContext().getRealPath(&quot;/index.html&quot;));
System.out.println(request.getServletContext().getRealPath(&quot;index.html&quot;));
System.out.println(request.getRequestURI());
System.out.println(request.getRequestURL());
System.out.println(request.getServletPath());
//获取GET请求参数信息
System.out.println(&quot;获取参数名对应的值&quot;);
String name = request.getParameter(&quot;name&quot;);
String[] hobbies = request.getParameterValues(&quot;hobby&quot;);
System.out.println(&quot;你好, &quot;+name);
System.out.println(&quot;你的兴趣爱好有：&quot;);
for(String hobby:hobbies)&#123;
    System.out.println(hobby);
&#125;

System.out.println(&quot;获取所有参数名，输出对应参数值&quot;);
java.util.Enumeration&lt;String&gt; paramNames = request.getParameterNames();
while(paramNames.hasMoreElements())&#123;
    String paramName = paramNames.nextElement();
    System.out.println(paramName);
    String[] paramValues = request.getParameterValues(paramName);
    for(String val : paramValues)&#123;
        System.out.println(val);
    &#125;
&#125;

System.out.println(&quot;使用Map&quot;);
java.util.Map&lt;String,String[]&gt;paramMap = request.getParameterMap();
for(java.util.Map.Entry&lt;String,String[]&gt;mapEntry: paramMap.entrySet())&#123;
    String paramName = mapEntry.getKey();
    System.out.println(&quot;参数 &quot;+paramName);
    String[] paramValues = request.getParameterValues(paramName);
    for(String val : paramValues)&#123;
        System.out.println(val);
    &#125;
&#125;
//获取GET请求行信息
System.out.println(&quot;获取&quot;+request.getMethod()+&quot;请求行信息&quot;);
System.out.println(request.getScheme());
System.out.println(request.getMethod());
System.out.println(request.getProtocol());
System.out.println(request.getQueryString());
System.out.println(java.net.URLEncoder.encode(&quot;张三&quot;,&quot;UTF-8&quot;));
//获取GET请求头信息
String userAgentValue=request.getHeader(&quot;user-agent&quot;);
System.out.println(&quot;user-agent请求头的值是：&quot;+userAgentValue);
java.util.Enumeration&lt;String&gt; headerNames = request.getHeaderNames();
while(headerNames.hasMoreElements())&#123;
    String headerName = headerNames.nextElement();
    java.util.Enumeration&lt;String&gt; headerValues = request.getHeaders(headerName);
    System.out.println(&quot;请求头:&quot;+headerName+&quot;,对应的请求头值有:&quot;);
    while(headerValues.hasMoreElements())&#123;
        String headerValue = headerValues.nextElement();
        System.out.println(headerValue);
    &#125;
&#125;
//获取Web服务器主机和浏览器主机信息
System.out.println(&quot;获取web服务器主机以及浏览器主机信息&quot;);
System.out.println(request.getServerName());
System.out.println(request.getServerPort());
System.out.println(request.getLocalAddr());
System.out.println(request.getLocalPort());
System.out.println(request.getLocalName());
System.out.println(request.getRemoteAddr());
System.out.println(request.getRemotePort());
System.out.println(request.getRemoteHost());
java.util.Locale browserLocale = request.getLocale();
System.out.println(browserLocale+&quot;*&quot;+browserLocale.getCountry()+&quot;*&quot;+browserLocale.getISO3Country());
java.util.Enumeration&lt;java.util.Locale&gt; browserLocales = request.getLocales();
while(browserLocales.hasMoreElements())&#123;
    java.util.Locale locale = browserLocales.nextElement();
    System.out.println(locale+&quot;#&quot;+locale.getCountry()+&quot;#&quot;+locale.getISO3Country());
&#125;
//获取URL Mappings
System.out.println(&quot;获取URL Mappings信息&quot;);
javax.servlet.http.HttpServletMapping mapping = request.getHttpServletMapping();
String mapName = mapping.getMappingMatch().name();
String value = mapping.getMatchValue();
String pattern = mapping.getPattern();
String servletName = mapping.getServletName();
System.out.println(&quot;servlet:&quot;+servletName);
System.out.println(&quot;URL type:&quot;+mapName);
System.out.println(&quot;URL value:&quot;+value);
System.out.println(&quot;URL pattern:&quot;+pattern);
</code></pre>
<h2 id="request请求对象的请求派发功能"><a href="#request请求对象的请求派发功能" class="headerlink" title="request请求对象的请求派发功能"></a>request请求对象的请求派发功能</h2><p>tomcat将收到的HTTP请求数据封装在request请求对象之后，可以用RequestDispatcher，通过RequestDispatcher可以实现request请求对象的配发功能，RequestDispatcher只是一个接口，具体实现要交给Web服务软件进行</p>
<p><code>RequestDispatcher getRequestDispatcher(String path)</code>path指向派发的目的地址，<code>RequestDispatcher</code>提供两种请求派发，一种是请求转发(forward)，另一种是请求包含(include)，下面只有请求转发的代码</p>
<p><strong>转发方：</strong></p>
<pre><code class="java">System.out.println(&quot;请求转发的基本使用&quot;);
java.util.Map&lt;String,Object&gt; map = new java.util.HashMap&lt;String, Object&gt;();
map.put(&quot;status&quot;,&quot;1&quot;);
map.put(&quot;message&quot;,&quot;登陆成功&quot;);
java.util.ArrayList&lt;String&gt; list = new java.util.ArrayList&lt;String&gt;();
list.add(&quot;aaa&quot;);
list.add(&quot;bbb&quot;);
list.add(&quot;ccc&quot;);
map.put(&quot;list&quot;,list);
request.setAttribute(&quot;map&quot;,map);
System.out.println(&quot;请求转发的类型是:&quot;+request.getDispatcherType());
request.getRequestDispatcher(&quot;BCDServlet&quot;).forward(request,response);
</code></pre>
<p><strong>接收方：</strong></p>
<pre><code class="java">System.out.println(&quot;通过请求转发request请求对象读取共享的属性信息&quot;);
System.out.println(&quot;请求转发的类型是:&quot;+request.getDispatcherType());
java.util.Map&lt;String,Object&gt; map = (java.util.Map&lt;String,Object&gt;) request.getAttribute(&quot;map&quot;);
String message = (String)map.get(&quot;message&quot;);
String status = (String)map.get(&quot;status&quot;);
java.util.ArrayList&lt;String&gt;list = (java.util.ArrayList&lt;String&gt;)map.get(&quot;list&quot;);
System.out.println(&quot;message:&quot;+message);
System.out.println(&quot;status:&quot;+status);
System.out.println(&quot;list:&quot;);
for(String l: list)&#123;
    System.out.println(l);
&#125;
</code></pre>
<p>具体不写了，之后学到了再细学</p>


	<b><span id="post-date">2022/10/17</span></b>
	<div id="tags">
		<ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag"># java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a></li></ul>
	</div>

	<div id="clear"></div>
</div>

<div id="cart">
	<button id="cart-hide" onclick="cartCg()">◀</button>
</div>
<script>
	showAIndex();
</script>

	</div>
	<script>
		hljs.highlightAll();
		hljs.initLineNumbersOnLoad();
	</script>
</span>
	<hr id="hidden">
	

	<script>
		hljs.highlightAll();
		hljs.initLineNumbersOnLoad();
		initBg();
		$(document).pjax('a','#pup',{fragment:'#pup'});
	</script>
</body>
</html>
